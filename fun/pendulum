<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Ensure proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Double Pendulum</title>
  <style>
    /* Global styles */
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    /* Controls container (top section) */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 10;
      padding: 10px 20px;
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    label {
      font-size: 14px;
      font-weight: bold;
      color: #ccc;
    }
    /* Slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      width: 150px;
      height: 8px;
      background: #444;
      border-radius: 5px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #ccc;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #ccc;
      border: none;
      border-radius: 50%;
      cursor: pointer;
    }
    #frequencyDisplay {
      font-size: 18px;
      font-weight: bold;
      min-width: 70px;
      text-align: center;
    }
    button {
      background: linear-gradient(145deg, #666, #888);
      border: none;
      color: #fff;
      padding: 10px;
      font-size: 20px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: transform 0.2s, box-shadow 0.2s;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
    }
    button:active {
      transform: scale(0.95);
    }
    /* Canvas styling */
    /* Both canvases now have a black background */
    #canvas,
    #waveCanvas {
      position: absolute;
      background: #000;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Controls -->
  <div id="controls">
    <div class="control-group">
      <label for="multiplierSlider">Pitch</label>
      <input type="range" id="multiplierSlider" min="6" max="120" step="1" value="60" />
    </div>
    <button id="toggleAudio">ðŸ”‡</button>
    <div class="control-group">
      <span id="frequencyDisplay">55 Hz</span>
    </div>
  </div>
  
  <!-- Canvases -->
  <canvas id="canvas"></canvas>
  <canvas id="waveCanvas"></canvas>
  
  <script>
    /***** Simulation Constants (Physics remains independent) *****/
    const r1Sim = 100;
    const r2Sim = 100;
    const g = 1;
    
    /***** Simulation State *****/
    let theta1 = Math.PI / 2, theta2 = Math.PI / 2;
    let omega1 = 0, omega2 = 0;
    
    /***** Drawing Variables *****/
    let scale = 1;
    let originX = 0, originY = 0;
    let m1 = 0, m2 = 0; // Bob radii in pixels
    
    /***** Trail Data for Visual Effect *****/
    let trails = []; // Each trail is { x, y, hue, age }
    const trailLifetime = 20000;
    let prevX2Sim = null, prevY2Sim = null;
    
    /***** Canvas & Context Setup *****/
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const waveCanvas = document.getElementById("waveCanvas");
    const waveCtx = waveCanvas.getContext("2d");
    
    /***** Controls *****/
    const multiplierSlider = document.getElementById("multiplierSlider");
    const frequencyDisplay = document.getElementById("frequencyDisplay");
    const toggleAudioButton = document.getElementById("toggleAudio");
    
    /***** Layout Constants *****/
    const waveHeight = 150; // Fixed oscilloscope height
    const horizontalPadding = 20;
    const verticalPadding = 20;
    
    /***** Canvas Layout Functions *****/
    function resizeCanvas() {
      const controlsHeight = document.getElementById("controls").offsetHeight;
      // Calculate available dimensions
      const availableWidth = window.innerWidth - horizontalPadding;
      const availableHeight = window.innerHeight - controlsHeight - waveHeight - verticalPadding;
      const squareSize = Math.min(availableWidth, availableHeight);
      
      // Set simulation canvas as a perfect square
      canvas.width = squareSize;
      canvas.height = squareSize;
      // Center horizontally; position below controls
      canvas.style.left = ((window.innerWidth - squareSize) / 2) + "px";
      canvas.style.top = controlsHeight + "px";
      
      // Set waveform canvas dimensions
      waveCanvas.width = availableWidth;
      waveCanvas.height = waveHeight;
      waveCanvas.style.left = (horizontalPadding / 2) + "px";
      waveCanvas.style.top = (window.innerHeight - waveHeight) + "px";
      
      updateDrawingParameters();
    }
    
    function updateDrawingParameters() {
      // Scale so that (r1Sim + r2Sim) spans 80% of canvas height, then apply a factor of 0.55.
      scale = canvas.height * 0.8 / (r1Sim + r2Sim) * 0.55;
      // Center the pivot both horizontally and vertically
      originX = canvas.width / 2;
      originY = canvas.height / 2;
      // Set bob sizes (minimum of 5 pixels)
      m1 = Math.max(5, scale * 8);
      m2 = Math.max(5, scale * 8);
    }
    
    function resetSimulation() {
      theta1 = Math.PI / 2;
      theta2 = Math.PI / 2;
      omega1 = 0;
      omega2 = 0;
      trails = [];
      prevX2Sim = null;
      prevY2Sim = null;
      lastTime = null;
    }
    
    /***** Audio Setup *****/
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const oscNode = audioCtx.createOscillator();
    oscNode.type = "sine";
    const oscGain = audioCtx.createGain();
    oscGain.gain.value = 0; // Start muted
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    const bufferLength = analyser.fftSize;
    const dataArray = new Uint8Array(bufferLength);
    
    // Connect audio nodes
    oscNode.connect(oscGain);
    oscGain.connect(analyser);
    analyser.connect(audioCtx.destination);
    oscNode.start();
    
    let audioEnabled = false;
    toggleAudioButton.addEventListener("click", async () => {
      if (audioCtx.state === "suspended") await audioCtx.resume();
      audioEnabled = !audioEnabled;
      toggleAudioButton.textContent = audioEnabled ? "ðŸ”Š" : "ðŸ”‡";
    });
    
    /***** Physics Update (Independent Simulation) *****/
    function updatePhysics(dt) {
      const mass1 = 10, mass2 = 10;
      const num1 = -g * (2 * mass1 + mass2) * Math.sin(theta1);
      const num2 = -mass2 * g * Math.sin(theta1 - 2 * theta2);
      const num3 = -2 * Math.sin(theta1 - theta2) * mass2;
      const num4 = omega2 * omega2 * r2Sim + omega1 * omega1 * r1Sim * Math.cos(theta1 - theta2);
      const den1 = r1Sim * (2 * mass1 + mass2 - mass2 * Math.cos(2 * theta1 - 2 * theta2));
      const a1 = (num1 + num2 + num3 * num4) / den1;
      
      const num5 = 2 * Math.sin(theta1 - theta2);
      const num6 = omega1 * omega1 * r1Sim * (mass1 + mass2);
      const num7 = g * (mass1 + mass2) * Math.cos(theta1);
      const num8 = omega2 * omega2 * r2Sim * mass2 * Math.cos(theta1 - theta2);
      const den2 = r2Sim * (2 * mass1 + mass2 - mass2 * Math.cos(2 * theta1 - 2 * theta2));
      const a2 = (num5 * (num6 + num7 + num8)) / den2;
      
      omega1 += a1 * dt;
      omega2 += a2 * dt;
      theta1 += omega1 * dt;
      theta2 += omega2 * dt;
    }
    
    /***** Drawing Functions *****/
    function drawPendulum(tipColor) {
      // Compute pendulum endpoints in simulation space
      const x1Sim = r1Sim * Math.sin(theta1);
      const y1Sim = r1Sim * Math.cos(theta1);
      const x2Sim = x1Sim + r2Sim * Math.sin(theta2);
      const y2Sim = y1Sim + r2Sim * Math.cos(theta2);
      
      // Convert simulation coordinates to canvas coordinates
      const x1 = originX + x1Sim * scale;
      const y1 = originY + y1Sim * scale;
      const x2 = originX + x2Sim * scale;
      const y2 = originY + y2Sim * scale;
      
      // Draw the rods
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Draw the first bob (elbow)
      ctx.fillStyle = "gray";
      ctx.beginPath();
      ctx.arc(x1, y1, m1, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw the second bob (tip)
      ctx.fillStyle = tipColor;
      ctx.beginPath();
      ctx.arc(x2, y2, m2, 0, Math.PI * 2);
      ctx.fill();
      
      return { x2Sim, y2Sim, x2, y2 };
    }
    
    function drawWaveform() {
      analyser.getByteTimeDomainData(dataArray);
      waveCtx.fillStyle = "#000";
      waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
      waveCtx.lineWidth = 2;
      waveCtx.strokeStyle = `hsla(${currentHue}, 100%, 50%, 1)`;
      waveCtx.beginPath();
      const sliceWidth = waveCanvas.width / bufferLength;
      let x = 0;
      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * waveCanvas.height / 2;
        if (i === 0) {
          waveCtx.moveTo(x, y);
        } else {
          waveCtx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      waveCtx.lineTo(waveCanvas.width, waveCanvas.height / 2);
      waveCtx.stroke();
    }
    
    /***** Animation Loop *****/
    let lastTime = null;
    const simSpeed = 60;        // Simulation speed factor
    const baseFreq = 55;
    const maxFreqForColor = 220;
    let currentHue = 0;
    
    function animate(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dtSeconds = (timestamp - lastTime) / 1000;
      const dt = dtSeconds * simSpeed;
      lastTime = timestamp;
      
      // Update simulation physics
      updatePhysics(dt);
      
      // Compute tip position and speed in simulation space
      const x1Sim = r1Sim * Math.sin(theta1);
      const y1Sim = r1Sim * Math.cos(theta1);
      const x2Sim = x1Sim + r2Sim * Math.sin(theta2);
      const y2Sim = y1Sim + r2Sim * Math.cos(theta2);
      
      let speedSim = 0;
      if (prevX2Sim !== null && prevY2Sim !== null) {
        const dxSim = x2Sim - prevX2Sim;
        const dySim = y2Sim - prevY2Sim;
        speedSim = Math.sqrt(dxSim * dxSim + dySim * dySim);
      }
      prevX2Sim = x2Sim;
      prevY2Sim = y2Sim;
      
      // Map speed to audio frequency
      const multiplier = parseFloat(multiplierSlider.value);
      const freq = baseFreq + speedSim * multiplier;
      const safeFreq = isFinite(freq) ? freq : baseFreq;
      oscNode.frequency.setTargetAtTime(safeFreq, audioCtx.currentTime, 0.01);
      oscGain.gain.setTargetAtTime(audioEnabled ? 0.2 : 0, audioCtx.currentTime, 0.01);
      frequencyDisplay.textContent = Math.round(safeFreq) + " Hz";
      
      // Map frequency to a hue value (logarithmic mapping)
      const normalizedPitch = (Math.log(safeFreq) - Math.log(baseFreq)) /
                              (Math.log(maxFreqForColor) - Math.log(baseFreq));
      currentHue = normalizedPitch * 240;
      const tipColor = `hsla(${currentHue}, 100%, 50%, 1)`;
      
      // Update trail for the pendulum tip
      const tipCanvasX = originX + x2Sim * scale;
      const tipCanvasY = originY + y2Sim * scale;
      trails.push({ x: tipCanvasX, y: tipCanvasY, hue: currentHue, age: 0 });
      
      // Clear and redraw the simulation canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      trails.forEach(trail => {
        const alpha = 1 - (trail.age / trailLifetime);
        ctx.fillStyle = `hsla(${trail.hue}, 100%, 50%, ${alpha})`;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, m2, 0, Math.PI * 2);
        ctx.fill();
        trail.age += dtSeconds * 1000;
      });
      trails = trails.filter(trail => trail.age < trailLifetime);
      
      drawPendulum(tipColor);
      drawWaveform();
      
      requestAnimationFrame(animate);
    }
    
    /***** Initialization & Event Listeners *****/
    function init() {
      resizeCanvas();
      window.addEventListener("resize", () => {
        cancelAnimationFrame(animationFrameRequest);
        resizeCanvas();
        resetSimulation();
        animationFrameRequest = requestAnimationFrame(animate);
      });
      animationFrameRequest = requestAnimationFrame(animate);
    }
    
    let animationFrameRequest;
    init();
  </script>
</body>
</html>
