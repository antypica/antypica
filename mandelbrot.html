<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Mandelbrot Explorer</title>
  <meta name="description" content="Mandelbrot Explorer written as an exercise in using ChatGPT to code. Color function by Hastings Greer, so check out his stuff on Mandelbrots." />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: "Helvetica Neue", Arial, sans-serif;
    }
    #app {
      position: relative;
      width: 100vw;
      height: 100dvh;
      background: black;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      user-select: none;
    }
    #mainCanvas { 
      z-index: 1; 
      cursor: crosshair;
    }    
    #marqueeCanvas { 
      z-index: 2; 
      cursor: crosshair;
    }
    .infoBox {
      position: fixed;
      bottom: calc(env(safe-area-inset-bottom, 0) + 20px);
      right: 20px;
      padding: 10px;
      border-radius: 4px;
      z-index: 1000;
    }
    @media (max-width: 768px) {
      .infoBox {
        right: auto;
        left: 50%;
        transform: translateX(-50%);
        bottom: calc(env(safe-area-inset-bottom, 0) + 20px);
      }
    }
    .infoBox .title {
      font-size: 1.35rem;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
      margin: 0 0 10px;
      text-align: center;
      white-space: nowrap;
    }
    .controls {
      display: grid;
      grid-template-columns: auto auto;
      gap: 10px;
      justify-content: center;
    }
    .controlButton {
      min-width: 100px;
      padding: 10px;
      font-size: 16px;
      color: rgba(255,255,255,0.7);
      background: rgba(70,70,70,0.4);
      border: 2px solid rgba(255,255,255,0.7);
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.2s, color 0.2s;
    }
    .controlButton:hover,
    .controlButton:active {
      color: rgba(255,255,255,1);
      border-color: rgba(255,255,255,1);
      background: rgba(70,70,70,0.8);
    }
    .controlButton:focus {
      outline: none;
    }
    .tipOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1rem;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
      pointer-events: none;
      z-index: 900;
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 4px;    
      transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import Decimal from "https://cdn.skypack.dev/decimal.js@10.3.1";
    import { App, Component, div, h1, button, canvas, Let } from "https://esm.sh/solenya";

    Decimal.set({ precision: 38 });

    function debounce(fn, ms) {
      let t;
      return function(...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), ms);
      };
    }

    const getNumericParam = (key, parser, defaultValue, min, max) => {
      const params = new URLSearchParams(window.location.search); 
      const str = params.get(key);
      if (str === null) return defaultValue;
      try {
        let val = parser(str);
        return (typeof val === "number" ? isNaN(val) : val?.isNaN?.()) ? defaultValue
          : (min !== undefined && val < min ? min : (max !== undefined && val > max ? max : val));
      } catch (e) {
        return defaultValue;
      }
    };

    function clearCanvas(canvasEl) {
      canvasEl.getContext("2d").clearRect(0, 0, canvasEl.width, canvasEl.height);
    }

    class Tip extends Component {
      element = undefined;
      tipState = "not_shown";

      view(attrs, content) {
        return div({
          ...attrs,
          onAttached: e => {
            this.element = e;
            this.element.style.opacity = "0";
            this.element.style.visibility = "hidden";
          }
        }, content);
      }

      show() {
        if (this.tipState === "not_shown") {
          this.tipState = "shown";
          this.element.style.opacity = "1";
          this.element.style.visibility = "visible";
        }
      }

      hide() {
        if (this.tipState === "shown") {
          this.tipState = "dismissed";
          this.element.style.opacity = "0";
          this.element.style.visibility = "hidden";
        }
      }
    }

    class Marquee extends Component {
      active = false;
      startPos = { x: 0, y: 0 };
      currentPos = { x: 0, y: 0 };
      canvasEl = undefined;
      onStart = undefined;
      onEnd = undefined;

      view(attrs) {
        return canvas({
          ...attrs,
          onpointerdown: e => this.handlePointerDown(e),
          onpointermove: e => this.handlePointerMove(e),
          onpointerup: e => this.handlePointerUp(e),
          onAttached: el => {
            this.canvasEl = el;
            el.addEventListener("touchstart", e => { e.preventDefault(); this.handlePointerDown(e); }, { passive: false });
            el.addEventListener("touchmove", e => { e.preventDefault(); this.handlePointerMove(e); }, { passive: false });
            el.addEventListener("touchend", e => { e.preventDefault(); this.handlePointerUp(e); }, { passive: false });
          }
        });
      }

      getEventCoords(e) {
        const rect = this.canvasEl.getBoundingClientRect();
        if (e.touches && e.touches.length) {
          return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        } else if (e.changedTouches && e.changedTouches.length) {
          return { x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top };
        }
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      handlePointerDown(e) {
        const coords = this.getEventCoords(e);
        this.active = true;
        this.startPos = { ...coords };
        this.currentPos = { ...coords };
        clearCanvas(this.canvasEl);
        this.onStart && this.onStart();
      }

      handlePointerMove(e) {
        if (!this.active) return;
        this.currentPos = this.getEventCoords(e);
        this.draw();
      }

      handlePointerUp(e) {
        if (!this.active) return;
        this.active = false;
        const rect = this.getRect();
        clearCanvas(this.canvasEl);
        this.onEnd && this.onEnd(rect);
      }

      draw() {
        if (!this.canvasEl) return;
        const ctx = this.canvasEl.getContext("2d");
        clearCanvas(this.canvasEl);
        const left = Math.min(this.startPos.x, this.currentPos.x);
        const top = Math.min(this.startPos.y, this.currentPos.y);
        const width = Math.abs(this.currentPos.x - this.startPos.x);
        const height = Math.abs(this.currentPos.y - this.startPos.y);
        ctx.save();
        ctx.strokeStyle = "#444";
        ctx.lineWidth = 2;
        ctx.setLineDash([6]);
        ctx.strokeRect(left, top, width, height);
        ctx.restore();
      }

      getRect() {
        return {
          left: Math.min(this.startPos.x, this.currentPos.x),
          top: Math.min(this.startPos.y, this.currentPos.y),
          width: Math.abs(this.currentPos.x - this.startPos.x),
          height: Math.abs(this.currentPos.y - this.startPos.y)
        };
      }
    }

    class MandelbrotComputer {
      gl = undefined;
      canvasEl;
      quadBuffer = null;
      refOrbitTexture = null;
      program = null;
      uniformLocations = {};

      // Low-res framebuffer objects (for lowQuality mode)
      lowResFramebuffer = null;
      lowResTexture = null;

      constructor(canvasEl) {
        this.canvasEl = canvasEl;
        const gl = this.canvasEl.getContext("webgl2", { preserveDrawingBuffer: true, antialias: false });
        if (!gl) {
          console.error("WebGL2 is not available.");
          alert("WebGL2 is not available.");
          return;
        }
        this.gl = gl;
        this.initShaders();
      }

      initShaders() {
        const gl = this.gl;
        const vsSource = `#version 300 es
          in vec2 a_position;
          void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;
        const fsSource = `#version 300 es
          precision highp float;
          uniform vec2  u_resolution;
          uniform vec2  u_fullResolution;
          uniform float u_centerX;
          uniform float u_centerY;
          uniform float u_scale;
          uniform int   u_maxIter;
          uniform int   u_maxIterDefault;
          uniform float u_bailout;
          uniform int   u_refLength;
          uniform float u_colorChoice;
          uniform sampler2D u_refOrbitTex;
          uniform int u_lowQuality;
          out vec4 fragColor;

          vec2 getRef(int i) {
            float fi  = float(i) + 0.5;
            float len = float(u_refLength);
            return texture(u_refOrbitTex, vec2(fi / len, 0.5)).rg;
          }

          void main() {
            vec2 coord;
            if(u_lowQuality == 1) {
              vec2 lowResCoord = vec2(gl_FragCoord.x + 0.5, gl_FragCoord.y + 0.5);
              lowResCoord.y = u_resolution.y - lowResCoord.y;
              coord = lowResCoord * (u_fullResolution / u_resolution) - vec2(0.5, 0.5);
            } else {
              coord = vec2(gl_FragCoord.x, u_fullResolution.y - gl_FragCoord.y);
            }

            vec2 dc = (coord - u_fullResolution * 0.5) / u_scale;
            vec2 dz = vec2(0.0);
            int refIndex = 0;
            int iteration = 0;
            int maxRefIteration = u_refLength - 1;

            for (int i = 0; i < 10000; i++) {
              if (iteration >= u_maxIter) break;
              vec2 refVal = getRef(refIndex);
              vec2 term1 = vec2(
                2.0 * (dz.x * refVal.x - dz.y * refVal.y),
                2.0 * (dz.x * refVal.y + dz.y * refVal.x)
              );
              vec2 term2 = vec2(dz.x * dz.x - dz.y * dz.y, 2.0 * dz.x * dz.y);
              dz = term1 + term2 + dc;
              refIndex++;
              if (refIndex >= u_refLength) break;
              vec2 z = getRef(refIndex) + dz;
              if (dot(z, z) > u_bailout) break;
              if (length(z) < length(dz) || refIndex == maxRefIteration) {
                dz = z;
                refIndex = 0;
              }
              iteration++;
            }

            float smoothIter = float(iteration);
            if (iteration < u_maxIter) {
              float lenz = length(getRef(refIndex) + dz);
              smoothIter += 1.0 - log(log(lenz)) / log(2.0);
            }
            float invColor = 1.0 / u_colorChoice;
            float cval = (smoothIter - float(u_maxIterDefault)) * invColor;
            float r = floor(255.0 * (0.5 - cos(cval) / 2.0));
            float g = floor(255.0 * (0.5 - cos(1.1214 * cval) / 2.0));
            float b = floor(255.0 * (0.5 - cos(0.8 * cval) / 2.0));

            fragColor = (iteration >= u_maxIter)
                        ? vec4(0.0, 0.0, 0.0, 1.0)
                        : vec4(r / 255.0, g / 255.0, b / 255.0, 1.0);
          }
        `;
        const vertexShader = this.compileShader(gl.VERTEX_SHADER, vsSource);
        const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fsSource);
        this.program = this.createProgram(vertexShader, fragmentShader);
        if (!this.program) {
          console.error("Failed to create shader program.");
          return;
        }
        this.uniformLocations = {
          resolution:      gl.getUniformLocation(this.program, "u_resolution"),
          fullResolution:  gl.getUniformLocation(this.program, "u_fullResolution"),
          centerX:         gl.getUniformLocation(this.program, "u_centerX"),
          centerY:         gl.getUniformLocation(this.program, "u_centerY"),
          scale:           gl.getUniformLocation(this.program, "u_scale"),
          maxIter:         gl.getUniformLocation(this.program, "u_maxIter"),
          maxIterDefault:  gl.getUniformLocation(this.program, "u_maxIterDefault"),
          bailout:         gl.getUniformLocation(this.program, "u_bailout"),
          refLength:       gl.getUniformLocation(this.program, "u_refLength"),
          colorChoice:     gl.getUniformLocation(this.program, "u_colorChoice"),
          refOrbitTex:     gl.getUniformLocation(this.program, "u_refOrbitTex"),
          lowQuality:      gl.getUniformLocation(this.program, "u_lowQuality")
        };
      }

      compileShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      createProgram(vs, fs) {
        const gl = this.gl;
        const program = gl.createProgram();
        if (!program || !vs || !fs) return null;
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error("Program link error:", gl.getProgramInfoLog(program));
          gl.deleteProgram(program);
          return null;
        }
        return program;
      }

      computeReferenceOrbit(maxIter, centerX, centerY) {
        const bailout = new Decimal(4);
        let refOrbit = [{ re: 0, im: 0 }];
        let z_re = new Decimal(0), z_im = new Decimal(0);
        for (let i = 0; i < maxIter; i++) {
          const new_re = z_re.mul(z_re).sub(z_im.mul(z_im)).add(centerX);
          const new_im = z_re.mul(z_im).mul(2).add(centerY);
          z_re = new_re; z_im = new_im;
          refOrbit.push({ re: z_re, im: z_im });
          if (z_re.mul(z_re).add(z_im.mul(z_im)).gt(bailout)) break;
        }
        return refOrbit;
      }

      updateRefOrbitTexture(refOrbit) {
        const gl = this.gl;
        const len = refOrbit.length;
        const data = new Float32Array(len * 2);
        refOrbit.forEach((pt, i) => {
          data[2 * i] = pt.re;
          data[2 * i + 1] = pt.im;
        });
        if (!this.refOrbitTexture) {
          this.refOrbitTexture = gl.createTexture();
        }
        gl.bindTexture(gl.TEXTURE_2D, this.refOrbitTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, len, 1, 0, gl.RG, gl.FLOAT, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        return len;
      }

      // Sets up the quad buffer if not already done.
      setupQuadBuffer() {
        const gl = this.gl;
        if (!this.quadBuffer) {
          this.quadBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
          const vertices = new Float32Array([
            -1, -1,  1, -1,  -1,  1,
            -1,  1,  1, -1,   1,  1,
          ]);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        } else {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
        }
        const posLoc = gl.getAttribLocation(this.program, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
      }

      // Applies uniforms and draws the scene.
      renderScene(resWidth, resHeight, fullWidth, fullHeight,
                  centerX, centerY, scale, maxIter, maxIterDefault, colorChoice, refLen, lowQualityFlag) {
        const gl = this.gl;
        gl.useProgram(this.program);
        gl.uniform2f(this.uniformLocations.resolution, resWidth, resHeight);
        gl.uniform2f(this.uniformLocations.fullResolution, fullWidth, fullHeight);
        gl.uniform1f(this.uniformLocations.centerX, centerX);
        gl.uniform1f(this.uniformLocations.centerY, centerY);
        gl.uniform1f(this.uniformLocations.scale, scale);
        gl.uniform1i(this.uniformLocations.maxIter, maxIter);
        gl.uniform1i(this.uniformLocations.maxIterDefault, maxIterDefault);
        gl.uniform1f(this.uniformLocations.bailout, 4.0);
        gl.uniform1i(this.uniformLocations.refLength, refLen);
        gl.uniform1f(this.uniformLocations.colorChoice, colorChoice);
        gl.uniform1i(this.uniformLocations.lowQuality, lowQualityFlag);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.refOrbitTexture);
        gl.uniform1i(this.uniformLocations.refOrbitTex, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      computeFractal(centerX, centerY, scale, maxIter, maxIterDefault, colorChoice, lowQuality = false) {
        const gl = this.gl;
        const fullWidth = this.canvasEl.width;
        const fullHeight = this.canvasEl.height;
        let resWidth = fullWidth, resHeight = fullHeight;
        let lowQualityFlag = 0;

        // If lowQuality is requested, render to a reduced resolution.
        if (lowQuality) {
          resWidth = Math.max(1, Math.floor(fullWidth / 3));
          resHeight = Math.max(1, Math.floor(fullHeight / 3));
          lowQualityFlag = 1;
          if (!this.lowResFramebuffer) {
            this.lowResFramebuffer = gl.createFramebuffer();
            this.lowResTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.lowResTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, resWidth, resHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.lowResFramebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.lowResTexture, 0);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, this.lowResTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, resWidth, resHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.lowResFramebuffer);
          }
          gl.viewport(0, 0, resWidth, resHeight);
        } else {
          gl.viewport(0, 0, fullWidth, fullHeight);
        }

        this.setupQuadBuffer();

        const refOrbit = this.computeReferenceOrbit(maxIter, centerX, centerY);
        const refLen = this.updateRefOrbitTexture(refOrbit);

        this.renderScene(
          resWidth, resHeight, fullWidth, fullHeight, centerX.toNumber(), centerY.toNumber(), scale.toNumber(), maxIter, maxIterDefault, colorChoice, refLen, lowQualityFlag
        );

        if (lowQuality) {
          // Blit the low-res framebuffer to the main canvas.
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.lowResFramebuffer);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
          gl.blitFramebuffer(
            0, 0, resWidth, resHeight,
            0, 0, fullWidth, fullHeight,
            gl.COLOR_BUFFER_BIT,
            gl.LINEAR
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.viewport(0, 0, fullWidth, fullHeight);
        }
      }
    }

    class MandelbrotExplorer extends Component {                 
      defaultCenterX = new Decimal(-0.75)
      defaultCenterY = new Decimal(0.0)
      defaultWidth = new Decimal(3.5)
      defaultHeight = new Decimal(2)
      defaultZ = new Decimal(1)                        
      centerX = undefined
      centerY = undefined;   
      z = undefined;  
      
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
      defaultCanvasScale = undefined;

      maxIterDefault = 1200;
      maxIter = this.maxIterDefault;
      colorChoice = 24.2;
      animating = false;
      zoomOutFactor = 2;
      maxCanvasScale = new Decimal("5e37")

      offscreenCanvas = document.createElement("canvas");    
      zoomStack = [];
      zoomDuration = 600;

      tip = new Tip();
      marquee = new Marquee();
      mandelbrotComputer = undefined;

      get canvasScale () { return this.z.times(this.defaultCanvasScale); }
      set canvasScale (value) { this.z = value.dividedBy(this.defaultCanvasScale) }      
      get zoomAnimationsEnabled() { return this.maxIter <= this.maxIterDefault; }

      attached() {        
        setTimeout(() => this.init(), 1);
        window.addEventListener("resize", debounce(() => this.updateLayout(), 100));
      }

      init() {
        this.mandelbrotComputer = new MandelbrotComputer(this.offscreenCanvas);        
        this.marquee.onStart = () => this.tip.show();
        this.marquee.onEnd = rect => this.processMarquee(rect);
        this.updateLayout(() => this.initFromURL());
      }

      updateLayout(afterLayout) {        
        this.canvasWidth = this.offscreenCanvas.width =this.canvasEl.width = this.marquee.canvasEl.width = window.innerWidth;
        this.canvasHeight = this.offscreenCanvas.height =this.canvasEl.height = this.marquee.canvasEl.height = window.innerHeight;  
        
        this.defaultCanvasScale = new Decimal ((this.canvasWidth / this.canvasHeight >= this.defaultWidth.dividedBy(this.defaultHeight).toNumber())
          ? (this.canvasHeight / this.defaultHeight * 0.8)
          : this.canvasWidth / this.defaultWidth);
        
        if (afterLayout)
          afterLayout();

        this.computeFractal();
      }

      initFromURL() {
        this.update(() => {
          this.centerX = getNumericParam ("x", d => new Decimal(d), this.defaultCenterX);
          this.centerY = getNumericParam ("y", d => new Decimal(d), this.defaultCenterY);
          this.z = getNumericParam ("z", d => new Decimal(d), this.defaultZ);
          this.maxIter = getNumericParam ("iterations", d => parseInt(d), this.maxIterDefault, 100, 100000)
        })        
      }
      
      updateURL() {
        if (
          this.centerX.equals(this.defaultCenterX) &&
          this.centerY.equals(this.defaultCenterY) &&
          this.z.equals(this.defaultZ) &&
          this.maxIter === this.maxIterDefault
        ) {
          history.replaceState(null, "", window.location.pathname);
        } else {                    
          const params = new URLSearchParams();
          const digits = this.z.toFixed(2).length;
          params.set("x", this.centerX.toSignificantDigits(digits).toString());
          params.set("y", this.centerY.toSignificantDigits(digits).toString());
          params.set("z", this.z.toFixed(2));
          params.set("iterations", this.maxIter);
          history.replaceState(null, "", window.location.pathname + "?" + params.toString());
        }
      }

      toggleMode() {
        if (this.animating) return;
        this.update(() => {      
          this.maxIter = this.maxIter <= this.maxIterDefault ? 9600 : this.maxIterDefault;          
        });
        setTimeout (() => this.computeFractal(), 1); 
      }

      computeFractal() {
        this.mandelbrotComputer.computeFractal(
          this.centerX, this.centerY, this.canvasScale, this.maxIter, this.maxIterDefault, this.colorChoice, this.animating
        );        
        const mainCtx = this.canvasEl.getContext("2d");
        mainCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
        mainCtx.drawImage(this.offscreenCanvas, 0, 0);
        if (! this.animating)
          this.updateURL();
      }

      processMarquee(rect) {
        const { left, top, width, height } = rect;
        if (width < 5 || height < 5) return;
        this.tip.hide();

        const canvasCenter = {
          x: new Decimal(this.canvasWidth).dividedBy(2),
          y: new Decimal(this.canvasHeight).dividedBy(2)
        };

        const canvasRect = {
          x1: new Decimal(left),
          y1: new Decimal(top),
          x2: new Decimal(left).plus(width),
          y2: new Decimal(top).plus(height)
        };

        const fractalRect = {
          x1: this.centerX.plus(canvasRect.x1.minus(canvasCenter.x).dividedBy(this.canvasScale)),
          y1: this.centerY.plus(canvasRect.y1.minus(canvasCenter.y).dividedBy(this.canvasScale)),
          x2: this.centerX.plus(canvasRect.x2.minus(canvasCenter.x).dividedBy(this.canvasScale)),
          y2: this.centerY.plus(canvasRect.y2.minus(canvasCenter.y).dividedBy(this.canvasScale))
        };

        const rectWidth = fractalRect.x2.minus(fractalRect.x1);
        const rectHeight = fractalRect.y2.minus(fractalRect.y1);
        const newCenterX = fractalRect.x1.plus(fractalRect.x2).dividedBy(2);
        const newCenterY = fractalRect.y1.plus(fractalRect.y2).dividedBy(2);

        const newScaleX = new Decimal(this.canvasWidth).dividedBy(rectWidth);
        const newScaleY = new Decimal(this.canvasHeight).dividedBy(rectHeight);
        const newScale = Decimal.min(newScaleX, newScaleY);

        if (!this.zoomAnimationsEnabled) {
          this.centerX = newCenterX;
          this.centerY = newCenterY;
          this.canvasScale = newScale;
          this.computeFractal();
        } else {
          const prevState = { centerX: this.centerX, centerY: this.centerY, scale: this.canvasScale };
          const targetState = { centerX: newCenterX, centerY: newCenterY, scale: newScale };
          this.zoomStack.push({ prevState, targetState });
          this.animateZoom(prevState, targetState);
        }
      }

      animateZoom(fromState, toState) {
        this.animating = true;
        const zoom = toState.scale.dividedBy(fromState.scale);
        const startTime = performance.now();

        const animateFrame = now => {
          let t = (now - startTime) / this.zoomDuration;
          if (t > 1) t = 1;

          const interpolatedZoomFactor = new Decimal(1).plus(new Decimal(t).times(zoom.minus(1)));
          const factor = new Decimal(t).times(zoom).dividedBy(interpolatedZoomFactor);

          // Linearly interpolate the center position based on the factor
          this.centerX = fromState.centerX.minus(factor.times(fromState.centerX.minus(toState.centerX)));
          this.centerY = fromState.centerY.minus(factor.times(fromState.centerY.minus(toState.centerY)));
          this.canvasScale = fromState.scale.times(interpolatedZoomFactor);

          if (t === 1) {
            this.animating = false;
          }
          this.computeFractal();
          if (t < 1) {
            requestAnimationFrame(animateFrame);
          }
        };

        requestAnimationFrame(animateFrame);
      }

      zoomOut() {
        if (this.animating) return;
        if (!this.zoomAnimationsEnabled) {
          this.zoomStack = [];
        }    
        if (this.zoomAnimationsEnabled && this.zoomStack.length > 0) {
          const zoomEntry = this.zoomStack.pop();
          this.animateZoom(zoomEntry.targetState, zoomEntry.prevState);
          return;
        }
        let newScale = this.canvasScale.dividedBy(this.zoomOutFactor);
        if (!this.zoomAnimationsEnabled && newScale.greaterThan(this.maxCanvasScale)) {
          newScale = this.maxCanvasScale;
        }
        if (newScale.lessThanOrEqualTo(this.defaultCanvasScale)) {
          this.reset();
        } else {
          this.canvasScale = newScale;
          this.computeFractal();
        }
      }

      reset() {
        if (this.animating) return;
        this.update (() => {
          this.zoomStack = [];
          this.z = this.defaultZ;
          this.centerX = this.defaultCenterX;
          this.centerY = this.defaultCenterY;          
          this.maxIter = this.maxIterDefault;          
        })
        setTimeout (() => this.computeFractal(), 1);
      }

      saveImage() {
        if (this.animating) return;
        const dataURL = this.canvasEl.toDataURL("image/jpeg");
        let filename = window.location.search.substring(1) || "mandelbrot";
        filename = filename.replace(/[^a-z0-9]/gi, '_') || "mandelbrot";
        if (!filename.startsWith("mandelbrot_")) filename = "mandelbrot_" + filename;
        filename += ".jpeg";
        const link = document.createElement("a");
        link.href = dataURL;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      view() {
        return div(
          canvas({
            id: "mainCanvas",
            width: this.canvasWidth,
            height: this.canvasHeight,
            onAttached: el => { this.canvasEl = el; }
          }),
          this.marquee.view({ id: "marqueeCanvas", width: this.canvasWidth, height: this.canvasHeight }),
          this.tip.view({ class: "tipOverlay" }, "click and drag to zoom"),
          div({ class: "infoBox" },
            h1({ class: "title" }, "Mandelbrot Explorer"),
            div({ class: "controls" },
              button({ class: "controlButton", onclick: () => this.saveImage() }, "Snapshot"),
              button({ class: "controlButton", onclick: () => this.toggleMode() }, this.zoomAnimationsEnabled ? "Fast" : "Deep"),
              button({ class: "controlButton", onclick: () => this.reset() }, "Reset"),
              button({ class: "controlButton", onclick: () => this.zoomOut() }, "Zoom Out")
            )
          )
        );
      }
    }

    window.app = new App(MandelbrotExplorer, "app");
  </script>
</body>
</html>