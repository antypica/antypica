<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Mandelbrot Explorer</title>
  <meta name="description" content="Mandelbrot Explorer written as en exercise in using ChatGPT to code. Color function by Hastings Greer, so check out his stuff on Mandelbrots." />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: "Helvetica Neue", Arial, sans-serif;
    }
    #app {
      position: relative;
      width: 100vw;
      height: 100dvh;
      background: black;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      user-select: none;
    }
    #mainCanvas { 
      z-index: 1; 
      cursor: crosshair;
    }    
    #marqueeCanvas { 
      z-index: 2; 
      cursor: crosshair;
    }
    .infoBox {
      position: fixed;
      bottom: calc(env(safe-area-inset-bottom, 0) + 20px);
      right: 20px;
      padding: 10px;
      border-radius: 4px;
      z-index: 1000;
    }
    @media (max-width: 768px) {
      .infoBox {
        right: auto;
        left: 50%;
        transform: translateX(-50%);
        bottom: calc(env(safe-area-inset-bottom, 0) + 20px);
      }
    }
    .infoBox .title {
      font-size: 1.35rem;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
      margin: 0 0 10px;
      text-align: center;
      white-space: nowrap;
    }
    .controls {
      display: grid;
      grid-template-columns: auto auto;
      gap: 10px;
      justify-content: center;
    }
    .controlButton {
      min-width: 100px;
      padding: 10px;
      font-size: 16px;
      color: rgba(255,255,255,0.7);
      background: rgba(70,70,70,0.4);
      border: 2px solid rgba(255,255,255,0.7);
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.2s, color 0.2s;
    }
    .controlButton:hover,
    .controlButton:active {
      color: rgba(255,255,255,1);
      border-color: rgba(255,255,255,1);
      background: rgba(70,70,70,0.8);
    }
    .controlButton:focus {
      outline: none;
    }
    .tipOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1rem;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
      pointer-events: none;
      z-index: 900;
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 4px;    
      transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import Decimal from "https://cdn.skypack.dev/decimal.js@10.3.1";
    import { App, Component, div, h1, button, canvas } from "https://esm.sh/solenya";

    Decimal.set({ precision: 38 });

    function debounce(fn, ms) {
      let t;
      return function(...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), ms);
      };
    }

    function clearCanvas(canvasEl) {
      canvasEl.getContext("2d").clearRect(0, 0, canvasEl.width, canvasEl.height);
    }

    class Tip extends Component {
      element = undefined;
      tipState = "not_shown";

      view(attrs, content) {
        return div({
          ...attrs,
          onAttached: e => {
            this.element = e;
            this.element.style.opacity = "0";
            this.element.style.visibility = "hidden";
          }
        }, content);
      }

      show() {
        if (this.tipState === "not_shown") {
          this.tipState = "shown";
          this.element.style.opacity = "1";
          this.element.style.visibility = "visible";
        }
      }

      hide() {
        if (this.tipState === "shown") {
          this.tipState = "dismissed";
          this.element.style.opacity = "0";
          this.element.style.visibility = "hidden";
        }
      }
    }

    class Marquee extends Component {
      active = false;
      startPos = { x: 0, y: 0 };
      currentPos = { x: 0, y: 0 };
      canvasEl = undefined;
      onStart = undefined;
      onEnd = undefined;

      view(attrs) {
        return canvas({
          ...attrs,
          onpointerdown: e => this.handlePointerDown(e),
          onpointermove: e => this.handlePointerMove(e),
          onpointerup: e => this.handlePointerUp(e),
          onAttached: el => {
            this.canvasEl = el;
            el.addEventListener("touchstart", e => { e.preventDefault(); this.handlePointerDown(e); }, { passive: false });
            el.addEventListener("touchmove", e => { e.preventDefault(); this.handlePointerMove(e); }, { passive: false });
            el.addEventListener("touchend", e => { e.preventDefault(); this.handlePointerUp(e); }, { passive: false });
          }
        });
      }

      getEventCoords(e) {
        const rect = this.canvasEl.getBoundingClientRect();
        if (e.touches && e.touches.length) {
          return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        } else if (e.changedTouches && e.changedTouches.length) {
          return { x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top };
        }
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      handlePointerDown(e) {
        const coords = this.getEventCoords(e);
        this.active = true;
        this.startPos = { ...coords };
        this.currentPos = { ...coords };
        clearCanvas(this.canvasEl);
        this.onStart && this.onStart();
      }

      handlePointerMove(e) {
        if (!this.active) return;
        this.currentPos = this.getEventCoords(e);
        this.draw();
      }

      handlePointerUp(e) {
        if (!this.active) return;
        this.active = false;
        const rect = this.getRect();
        clearCanvas(this.canvasEl);
        this.onEnd && this.onEnd(rect);
      }

      draw() {
        if (!this.canvasEl) return;
        const ctx = this.canvasEl.getContext("2d");
        clearCanvas(this.canvasEl);
        const left = Math.min(this.startPos.x, this.currentPos.x);
        const top = Math.min(this.startPos.y, this.currentPos.y);
        const width = Math.abs(this.currentPos.x - this.startPos.x);
        const height = Math.abs(this.currentPos.y - this.startPos.y);
        ctx.save();
        ctx.strokeStyle = "#444";
        ctx.lineWidth = 2;
        ctx.setLineDash([6]);
        ctx.strokeRect(left, top, width, height);
        ctx.restore();
      }

      getRect() {
        return {
          left: Math.min(this.startPos.x, this.currentPos.x),
          top: Math.min(this.startPos.y, this.currentPos.y),
          width: Math.abs(this.currentPos.x - this.startPos.x),
          height: Math.abs(this.currentPos.y - this.startPos.y)
        };
      }
    }

    class MandelbrotComputer {
      gl = undefined;
      canvasEl;
      quadBuffer = null;
      refOrbitTexture = null;
      program = null;
      uniformLocations = {};

      // Low-res framebuffer objects (for lowQuality mode)
      lowResFramebuffer = null;
      lowResTexture = null;

      constructor(canvasEl) {
        this.canvasEl = canvasEl;
        const gl = this.canvasEl.getContext("webgl2", { preserveDrawingBuffer: true, antialias: false });
        if (!gl) {
          console.error("WebGL2 is not available.");
          alert("WebGL2 is not available.");
          return;
        }
        this.gl = gl;
        this.initShaders();
      }

      initShaders() {
        const gl = this.gl;
        const vsSource = `#version 300 es
          in vec2 a_position;
          void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;
        const fsSource = `#version 300 es
          precision highp float;
          uniform vec2  u_resolution;
          uniform vec2  u_fullResolution;
          uniform float u_centerX;
          uniform float u_centerY;
          uniform float u_scale;
          uniform int   u_maxIter;
          uniform float u_bailout;
          uniform int   u_refLength;
          uniform float u_colorChoice;
          uniform sampler2D u_refOrbitTex;
          uniform int u_lowQuality;
          out vec4 fragColor;

          vec2 getRef(int i) {
            float fi  = float(i) + 0.5;
            float len = float(u_refLength);
            return texture(u_refOrbitTex, vec2(fi / len, 0.5)).rg;
          }

          void main() {
            vec2 coord;
            if(u_lowQuality == 1) {
              vec2 lowResCoord = vec2(gl_FragCoord.x + 0.5, gl_FragCoord.y + 0.5);
              lowResCoord.y = u_resolution.y - lowResCoord.y;
              coord = lowResCoord * (u_fullResolution / u_resolution) - vec2(0.5, 0.5);
            } else {
              coord = vec2(gl_FragCoord.x, u_fullResolution.y - gl_FragCoord.y);
            }

            vec2 dc = (coord - u_fullResolution * 0.5) / u_scale;
            vec2 dz = vec2(0.0);
            int refIndex = 0;
            int iteration = 0;
            int maxRefIteration = u_refLength - 1;

            for (int i = 0; i < 10000; i++) {
              if (iteration >= u_maxIter) break;
              vec2 refVal = getRef(refIndex);
              vec2 term1 = vec2(
                2.0 * (dz.x * refVal.x - dz.y * refVal.y),
                2.0 * (dz.x * refVal.y + dz.y * refVal.x)
              );
              vec2 term2 = vec2(dz.x * dz.x - dz.y * dz.y, 2.0 * dz.x * dz.y);
              dz = term1 + term2 + dc;
              refIndex++;
              if (refIndex >= u_refLength) break;
              vec2 z = getRef(refIndex) + dz;
              if (dot(z, z) > u_bailout) break;
              if (length(z) < length(dz) || refIndex == maxRefIteration) {
                dz = z;
                refIndex = 0;
              }
              iteration++;
            }

            float smoothIter = float(iteration);
            if (iteration < u_maxIter) {
              float lenz = length(getRef(refIndex) + dz);
              smoothIter += 1.0 - log(log(lenz)) / log(2.0);
            }
            float invColor = 1.0 / u_colorChoice;
            int alt_u_maxIter = 1200;
            float cval = (smoothIter - float(alt_u_maxIter)) * invColor;
            float r = floor(255.0 * (0.5 - cos(cval) / 2.0));
            float g = floor(255.0 * (0.5 - cos(1.1214 * cval) / 2.0));
            float b = floor(255.0 * (0.5 - cos(0.8 * cval) / 2.0));

            fragColor = (iteration >= u_maxIter)
                        ? vec4(0.0, 0.0, 0.0, 1.0)
                        : vec4(r / 255.0, g / 255.0, b / 255.0, 1.0);
          }
        `;
        const vertexShader = this.compileShader(gl.VERTEX_SHADER, vsSource);
        const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fsSource);
        this.program = this.createProgram(vertexShader, fragmentShader);
        if (!this.program) {
          console.error("Failed to create shader program.");
          return;
        }
        this.uniformLocations = {
          resolution:      gl.getUniformLocation(this.program, "u_resolution"),
          fullResolution:  gl.getUniformLocation(this.program, "u_fullResolution"),
          centerX:         gl.getUniformLocation(this.program, "u_centerX"),
          centerY:         gl.getUniformLocation(this.program, "u_centerY"),
          scale:           gl.getUniformLocation(this.program, "u_scale"),
          maxIter:         gl.getUniformLocation(this.program, "u_maxIter"),
          bailout:         gl.getUniformLocation(this.program, "u_bailout"),
          refLength:       gl.getUniformLocation(this.program, "u_refLength"),
          colorChoice:     gl.getUniformLocation(this.program, "u_colorChoice"),
          refOrbitTex:     gl.getUniformLocation(this.program, "u_refOrbitTex"),
          lowQuality:      gl.getUniformLocation(this.program, "u_lowQuality")
        };
      }

      compileShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      createProgram(vs, fs) {
        const gl = this.gl;
        const program = gl.createProgram();
        if (!program || !vs || !fs) return null;
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error("Program link error:", gl.getProgramInfoLog(program));
          gl.deleteProgram(program);
          return null;
        }
        return program;
      }

      computeReferenceOrbit(maxIter, centerXDec, centerYDec) {
        const bailout = new Decimal(4);
        let refOrbit = [{ re: 0, im: 0 }];
        let z_re = new Decimal(0), z_im = new Decimal(0);
        for (let i = 0; i < maxIter; i++) {
          const new_re = z_re.mul(z_re).sub(z_im.mul(z_im)).add(centerXDec);
          const new_im = z_re.mul(z_im).mul(2).add(centerYDec);
          z_re = new_re; z_im = new_im;
          refOrbit.push({ re: parseFloat(z_re.toString()), im: parseFloat(z_im.toString()) });
          if (z_re.mul(z_re).add(z_im.mul(z_im)).gt(bailout)) break;
        }
        return refOrbit;
      }

      updateRefOrbitTexture(refOrbit) {
        const gl = this.gl;
        const len = refOrbit.length;
        const data = new Float32Array(len * 2);
        refOrbit.forEach((pt, i) => {
          data[2 * i] = pt.re;
          data[2 * i + 1] = pt.im;
        });
        if (!this.refOrbitTexture) {
          this.refOrbitTexture = gl.createTexture();
        }
        gl.bindTexture(gl.TEXTURE_2D, this.refOrbitTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, len, 1, 0, gl.RG, gl.FLOAT, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        return len;
      }

      // Sets up the quad buffer if not already done.
      setupQuadBuffer() {
        const gl = this.gl;
        if (!this.quadBuffer) {
          this.quadBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
          const vertices = new Float32Array([
            -1, -1,  1, -1,  -1,  1,
            -1,  1,  1, -1,   1,  1,
          ]);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        } else {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
        }
        const posLoc = gl.getAttribLocation(this.program, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
      }

      // Applies uniforms and draws the scene.
      renderScene(resWidth, resHeight, fullWidth, fullHeight, centerX, centerY, scale, maxIter, colorChoice, refLen, lowQualityFlag) {
        const gl = this.gl;
        gl.useProgram(this.program);
        gl.uniform2f(this.uniformLocations.resolution, resWidth, resHeight);
        gl.uniform2f(this.uniformLocations.fullResolution, fullWidth, fullHeight);
        gl.uniform1f(this.uniformLocations.centerX, centerX);
        gl.uniform1f(this.uniformLocations.centerY, centerY);
        gl.uniform1f(this.uniformLocations.scale, scale);
        gl.uniform1i(this.uniformLocations.maxIter, maxIter);
        gl.uniform1f(this.uniformLocations.bailout, 4.0);
        gl.uniform1i(this.uniformLocations.refLength, refLen);
        gl.uniform1f(this.uniformLocations.colorChoice, colorChoice);
        gl.uniform1i(this.uniformLocations.lowQuality, lowQualityFlag);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.refOrbitTexture);
        gl.uniform1i(this.uniformLocations.refOrbitTex, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      computeFractal(centerX, centerY, scale, maxIter, colorChoice, lowQuality = false) {
        const gl = this.gl;
        const fullWidth = this.canvasEl.width;
        const fullHeight = this.canvasEl.height;
        let resWidth = fullWidth, resHeight = fullHeight;
        let lowQualityFlag = 0;

        // If lowQuality is requested, render to a reduced resolution.
        if (lowQuality) {
          resWidth = Math.max(1, Math.floor(fullWidth / 3));
          resHeight = Math.max(1, Math.floor(fullHeight / 3));
          lowQualityFlag = 1;
          if (!this.lowResFramebuffer) {
            this.lowResFramebuffer = gl.createFramebuffer();
            this.lowResTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.lowResTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, resWidth, resHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.lowResFramebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.lowResTexture, 0);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, this.lowResTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, resWidth, resHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.lowResFramebuffer);
          }
          gl.viewport(0, 0, resWidth, resHeight);
        } else {
          gl.viewport(0, 0, fullWidth, fullHeight);
        }

        this.setupQuadBuffer();

        // Compute and update reference orbit.
        const refOrbit = this.computeReferenceOrbit(maxIter, centerX, centerY);
        const refLen = this.updateRefOrbitTexture(refOrbit);

        // Convert Decimal values to float.
        const centerXFloat = parseFloat(centerX.toString());
        const centerYFloat = parseFloat(centerY.toString());
        const scaleFloat = parseFloat(scale.toString());

        this.renderScene(resWidth, resHeight, fullWidth, fullHeight,
          centerXFloat, centerYFloat, scaleFloat, maxIter, colorChoice, refLen, lowQualityFlag);

        if (lowQuality) {
          // Blit the low-res framebuffer to the main canvas.
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.lowResFramebuffer);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
          gl.blitFramebuffer(
            0, 0, resWidth, resHeight,
            0, 0, fullWidth, fullHeight,
            gl.COLOR_BUFFER_BIT,
            gl.LINEAR
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.viewport(0, 0, fullWidth, fullHeight);
        }
      }
    }

    class MandelbrotExplorer extends Component {
      width = window.innerWidth;
      height = window.innerHeight;
      centerX = undefined;
      centerY = undefined;
      scale = undefined;
      defaultCenterX = undefined;
      defaultCenterY = undefined;
      defaultScale = undefined;

      maxIter = 1200;
      colorChoice = 24.2;
      animating = false;
      zoomOutFactor = 2;

      offscreenCanvas = document.createElement("canvas");
      zoomAnimationsEnabled = true;
      zoomStack = [];
      zoomDuration = 600;

      tip = new Tip();
      marquee = new Marquee();
      mandelbrotComputer = undefined;

      attached() {        
        setTimeout(() => this.init(), 1);
        window.addEventListener("resize", debounce(() => this.updateLayout(), 100));
      }

      init() {
        this.mandelbrotComputer = new MandelbrotComputer(this.offscreenCanvas);        
        this.marquee.onStart = () => this.tip.show();
        this.marquee.onEnd = rect => this.processMarquee(rect);
        this.updateLayout(() => this.initFromURL())        
      }

      updateLayout(afterLayout) {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.offscreenCanvas.width  = this.width;
        this.offscreenCanvas.height = this.height;
        this.canvasEl.width  = this.width;
        this.canvasEl.height = this.height;
        this.marquee.canvasEl.width  = this.width;
        this.marquee.canvasEl.height = this.height;

        const minX = -2.5, maxX = 1.0, minY = -1.0, maxY = 1.0;
        const computedDefaultScale = (this.width / this.height >= (maxX - minX) / (maxY - minY))
          ? (this.height / (maxY - minY) * 0.8)
          : (this.width / (maxX - minX));
        const defaultCenterX = (minX + maxX) / 2;
        const defaultCenterY = 0;

        this.defaultCenterX = new Decimal(defaultCenterX.toString());
        this.defaultCenterY = new Decimal(defaultCenterY.toString());
        this.defaultScale   = new Decimal(computedDefaultScale.toString());

        if (afterLayout)
          afterLayout()

        this.computeFractal();
      }

      initFromURL() {
        const params = new URLSearchParams(window.location.search);
        const hasPos = params.has("x") && params.has("y") && params.has("z")
        this.centerX = hasPos ? new Decimal(params.get("x")) : this.defaultCenterX;
        this.centerY = hasPos ? new Decimal(params.get("y")) : this.defaultCenterY;
        this.scale   = hasPos ? new Decimal(params.get("z")) : this.defaultScale;
      }
      
      updateURL() {
        if (
          this.centerX.equals(this.defaultCenterX) &&
          this.centerY.equals(this.defaultCenterY) &&
          this.scale.equals(this.defaultScale)
        ) {
          history.replaceState(null, "", window.location.pathname);
        } else {          
          const digits = this.scale.toFixed(0).length;
          const params = new URLSearchParams();
          params.set("x", this.centerX.toSignificantDigits(digits).toString());
          params.set("y", this.centerY.toSignificantDigits(digits).toString());
          params.set("z", this.scale.toFixed(0));
          history.replaceState(null, "", window.location.pathname + "?" + params.toString());
        }
      }

      toggleMode() {
        if (this.animating) return;
        this.update(() => {
          this.zoomAnimationsEnabled = !this.zoomAnimationsEnabled;
          this.maxIter = this.zoomAnimationsEnabled ? 1200 : 9600;
          this.computeFractal();
        });
      }

      computeFractal(scaleOverride, cxOverride, cyOverride, lowQuality = false) {
        if (scaleOverride !== undefined && cxOverride !== undefined && cyOverride !== undefined) {
          this.scale   = new Decimal(scaleOverride.toString());
          this.centerX = new Decimal(cxOverride.toString());
          this.centerY = new Decimal(cyOverride.toString());
        }
        this.mandelbrotComputer.computeFractal(this.centerX, this.centerY, this.scale, this.maxIter, this.colorChoice, lowQuality);
        const mainCtx = this.canvasEl.getContext("2d");
        mainCtx.clearRect(0, 0, this.width, this.height);
        mainCtx.drawImage(this.offscreenCanvas, 0, 0);
      }

      processMarquee(rect) {
        const { left, top, width, height } = rect;
        if (width < 5 || height < 5) return;
        this.tip.hide();

        const canvasCenterX = new Decimal(this.width).dividedBy(2);
        const canvasCenterY = new Decimal(this.height).dividedBy(2);
        const x1 = new Decimal(left.toString());
        const y1 = new Decimal(top.toString());
        const x2 = x1.plus(new Decimal(width.toString()));
        const y2 = y1.plus(new Decimal(height.toString()));

        const fractalX1 = this.centerX.plus(x1.minus(canvasCenterX).dividedBy(this.scale));
        const fractalY1 = this.centerY.plus(y1.minus(canvasCenterY).dividedBy(this.scale));
        const fractalX2 = this.centerX.plus(x2.minus(canvasCenterX).dividedBy(this.scale));
        const fractalY2 = this.centerY.plus(y2.minus(canvasCenterY).dividedBy(this.scale));

        const deltaX = fractalX2.minus(fractalX1);
        const newCenterX = fractalX1.plus(fractalX2).dividedBy(2);
        const newCenterY = fractalY1.plus(fractalY2).dividedBy(2);
        const newScale = new Decimal(this.width).dividedBy(deltaX);

        if (this.zoomAnimationsEnabled) {
          const prevState = { centerX: this.centerX, centerY: this.centerY, scale: this.scale };
          const targetState = { centerX: newCenterX, centerY: newCenterY, scale: newScale };

          const A_dec = newScale.dividedBy(this.centerX);  // Using current scale
          const halfW_dec = new Decimal(this.width).dividedBy(2);
          const halfH_dec = new Decimal(this.height).dividedBy(2);
          const BxDec = this.centerX.minus(newCenterX).times(newScale)
            .plus(halfW_dec.times(new Decimal(1).minus(A_dec)));
          const ByDec = this.centerY.minus(newCenterY).times(newScale)
            .plus(halfH_dec.times(new Decimal(1).minus(A_dec)));

          const zoomEntry = { prevState, targetState, A: A_dec, B: { x: BxDec, y: ByDec } };
          this.zoomStack.push(zoomEntry);
          this.animateZoomIn(zoomEntry);
        } else {
          this.centerX = newCenterX;
          this.centerY = newCenterY;
          this.scale   = newScale;
          this.computeFractal(newScale, newCenterX, newCenterY);
          this.updateURL();
        }
      }

      animateZoom(fromState, toState, durationMs, onComplete) {
        this.animating = true;
        const A = toState.scale.dividedBy(fromState.scale);
        const startTime = performance.now();
        const animateFrame = now => {
          let t = (now - startTime) / durationMs;
          if (t > 1) t = 1;
          const onePlus = new Decimal(1).plus(new Decimal(t).times(A.minus(1)));
          const currentScale = fromState.scale.times(onePlus);
          const factor = new Decimal(t).times(A).dividedBy(onePlus);
          const currentCenterX = fromState.centerX.minus(factor.times(fromState.centerX.minus(toState.centerX)));
          const currentCenterY = fromState.centerY.minus(factor.times(fromState.centerY.minus(toState.centerY)));
          this.computeFractal(currentScale, currentCenterX, currentCenterY, true);
          if (t < 1) requestAnimationFrame(animateFrame);
          else {
            this.centerX = toState.centerX;
            this.centerY = toState.centerY;
            this.scale   = toState.scale;
            this.updateURL();
            this.computeFractal(this.scale, this.centerX, this.centerY);
            this.animating = false;
            onComplete && onComplete();
          }
        };
        requestAnimationFrame(animateFrame);
      }

      animateZoomIn(zoomEntry) {
        this.animateZoom(zoomEntry.prevState, zoomEntry.targetState, this.zoomDuration);
      }

      animateZoomOut(zoomEntry) {
        this.animateZoom(zoomEntry.targetState, zoomEntry.prevState, this.zoomDuration);
      }

      zoomOut() {
        if (this.animating) return;
        if (!this.zoomAnimationsEnabled) { 
          this.zoomStack.length = 0;
          const newScale = this.scale.dividedBy(this.zoomOutFactor);
          if (newScale.lessThanOrEqualTo(this.defaultScale)) this.reset();
          else {
            this.scale = newScale;
            this.computeFractal(newScale, this.centerX, this.centerY);
            this.updateURL();
          }
          return;
        }
        if (this.zoomStack.length > 0) {
          const zoomEntry = this.zoomStack.pop();
          this.animateZoomOut(zoomEntry);
        } else {
          const newScale = this.scale.dividedBy(this.zoomOutFactor);
          if (newScale.lessThanOrEqualTo(this.defaultScale)) this.reset();
          else {
            this.scale = newScale;
            this.computeFractal(newScale, this.centerX, this.centerY);
            this.updateURL();
          }
        }
      }

      reset() {
        if (this.animating) return;
        this.centerX = this.defaultCenterX;
        this.centerY = this.defaultCenterY;
        this.scale   = this.defaultScale;
        this.computeFractal(this.defaultScale, this.defaultCenterX, this.defaultCenterY);
        this.updateURL();
      }

      saveImage() {
        if (this.animating) return;
        const dataURL = this.canvasEl.toDataURL("image/jpeg");
        let filename = window.location.search.substring(1) || "mandelbrot";
        filename = filename.replace(/[^a-z0-9]/gi, '_') || "mandelbrot";
        if (!filename.startsWith("mandelbrot_")) filename = "mandelbrot_" + filename;
        filename += ".jpeg";
        const link = document.createElement("a");
        link.href = dataURL;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      view() {
        return div(
          canvas({
            id: "mainCanvas",
            width: this.width,
            height: this.height,
            onAttached: el => { this.canvasEl = el; }
          }),
          this.marquee.view({ id: "marqueeCanvas", width: this.width, height: this.height }),
          this.tip.view({ class: "tipOverlay" }, "click and drag to zoom"),
          div({ class: "infoBox" },
            h1({ class: "title" }, "Mandelbrot Explorer"),
            div({ class: "controls" },
              button({ class: "controlButton", onclick: () => this.saveImage() }, "Snapshot"),
              button({ class: "controlButton", onclick: () => this.toggleMode() }, this.zoomAnimationsEnabled ? "Fast" : "Deep"),
              button({ class: "controlButton", onclick: () => this.reset() }, "Reset"),
              button({ class: "controlButton", onclick: () => this.zoomOut() }, "Zoom Out")
            )
          )
        );
      }
    }

    window.app = new App(MandelbrotExplorer, "app");
  </script>
</body>
</html>